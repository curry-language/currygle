----------------------------------------------------------------------
--- This modules defines the trie structures used in the index of Currygle
--- and operations to create the trie structures for various kinds of
--- entities in Curry programs.
---
--- @author Helge Knof (with changes by Michael Hanus)
--- @version May 2025
----------------------------------------------------------------------
{-# OPTIONS_FRONTEND -Wno-incomplete-patterns #-}

module Index.Trie
  ( Trie(..), emptyTrie, addIndexItemsToTrie, createSignatureTrie )
 where

import Data.Map
import FlatCurry.Types
import FlatCurry.FlexRigid
import RW.Base

import Index.Helper
import Index.Item
import Index.Signature

------------------------------------------------------------------------------
-- A Trie, a type of searchtree where you can search by a list of type [k],
-- and it returns all values of type v stored under the key in the tree.
data Trie k v = Node (Map k (Trie k v)) [v]
    deriving (Show, Read)

emptyTrie :: Trie k v
emptyTrie = Node (Data.Map.empty) []

-- Adds an element of type v into the list stored under the key [k]
addToTrie :: Ord k => Trie k v -> [k] -> v -> Trie k v
-- If we found the key, i.e., the key list is empty, add the new value
-- to the current Trie:
addToTrie (Node m vs) [] v  = Node m (v:vs)
addToTrie (Node m vs) (k:ks) v
  | member k m = let Just subTrie = (Data.Map.lookup k m)
                 in Node (insert k (addToTrie subTrie ks v) m) vs
  | otherwise  = Node (insert k (addToTrie emptyTrie ks v) m) vs

------------------------------------------------
-- Creation of the different IndexTrees
------------------------------------------------

-- Creates a trie storing the signature for all TypeIndex and FunctionIndex
-- in the list
createSignatureTrie :: [(Int,IndexItem)] -> Trie Signature (Int,Int)
createSignatureTrie items = createSignatureTrieRec items
 where
  createSignatureTrieRec :: [(Int,IndexItem)] -> Trie Signature (Int, Int)
  createSignatureTrieRec []         = emptyTrie
  createSignatureTrieRec ((n,i):is) = case signatruesOfItem i of
    Nothing   -> createSignatureTrieRec is
    Just sigs -> addAllSignatures (createSignatureTrieRec is) sigs n

  addAllSignatures t []     _ = t
  addAllSignatures t (s:ss) i = addAllSignatures
                                  (addItemToTrie t s (i, length s)) ss i

--- Construct a trie from a list of numbered `IndexItem`s w.r.t. a function
--- to extract a list of keys from each `IndexItem`.
--- Adds the position of all IndexItems in the list to the trie under all
--- suffixes as keys.
addIndexItemsToTrie :: Ord k => (IndexItem -> [[k]]) -> [(Int,IndexItem)]
                     -> Trie k (Int,Int)
addIndexItemsToTrie f = addIndexItems emptyTrie
 where
  addIndexItems trie []       = trie
  addIndexItems trie ((ni,item):nitems) =
    addIndexItems (addItemsToTrie trie ni (f item)) nitems

  -- Adds a list of keys for a given item position into a trie.
  addItemsToTrie trie ipos keys =
    foldr (\k t -> addItemToTrie t k (ipos,length k)) trie keys

-- Adds the item (third argument) into the given trie under all sublists
-- of the key (second argument) including the empty one.
addItemToTrie :: Ord k => Trie k v -> [k] -> v -> Trie k v
addItemToTrie trie str item =
  foldr (\(key,value) tr -> addToTrie tr key value) trie
        (map (\ks -> (ks,item))
             (concatMap allPrefixes (allSuffixes str) ++ [[]]))

-- Returns all suffixes of a list.
allSuffixes :: [a] -> [[a]]
allSuffixes []       = []
allSuffixes (c:cs)   = (c:cs) : allSuffixes cs

-- Returns all prefixes of a list.
allPrefixes :: [a] -> [[a]]
allPrefixes = map reverse . allSuffixes . reverse

------------------------------------------------------------------------------
-- Auto generated by curry-rw-data
------------------------------------------------------------------------------

instance (ReadWrite a,ReadWrite b) => ReadWrite (Trie a b) where
  readRW strs r0 = (Node a' b',r2)
    where
      (a',r1) = readRW strs r0
      (b',r2) = readRW strs r1

  showRW params strs0 (Node a' b') = (strs2,show1 . show2)
    where
      (strs1,show1) = showRW params strs0 a'
      (strs2,show2) = showRW params strs1 b'

  writeRW params h (Node a' b') strs =
    writeRW params h a' strs >>= writeRW params h b'

  typeOf n = RWType "Trie" [typeOf (get_a n),typeOf (get_b n)]
    where
      get_a :: Trie a' b' -> a'
      get_a _ = failed
      get_b :: Trie a' b' -> b'
      get_b _ = failed

------------------------------------------------------------------------------
